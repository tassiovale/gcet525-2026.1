# Introdução

## Diferença enter compilador e interpretador

## Fases da compilação
1. Análise lexical (scanning)
	- converte o código bruto em uma sequência de tokens → ignora comentários e espaços
    - int x = 10; → `[KW_INT][ID(x)][=][NUM(10)][;]` → `[tipo de dado][nome da variável][operador][literal numérico][pontuação]`
2. Análise sintática (parsing)
    - verifica se esses tokens estão organizados de forma correta sintaxicamente
      - caso esteja incorreto, retorna um erro de sintaxe na IDE
    - retorna uma árvore sintática
3. Análise semântica
    - verifica se o código “faz sentido” logicamente
      - verifica erros de declaração de variáveis, tipos e etc
    - retorna uma arvore de sintaxe com mais anotações
4. Geração de código intermediário
    - está entre linguagem de alto nível e baixo nível → linguagem interna do compilador
    - simplifica o processo de otimização executando técnicas como: eliminar código morto, otimizar loops, reutilizar expressões comuns
    - não é específico de nenhuma máquina, podendo ser facilmente migrado
5. Otimização de código
    - aprimora ainda mais o código intermediário para diminuir o tempo de execução
    - pré computa constantes, elimina cópias de variáveis, reaproveita resultados e etc
6. Geração de código
    - é onde a linguagem intermediária é transformada em código de máquina ou assembly 

## Diferença entre pré-processador, compilador, assembler, linker

## Definir linguagem intermediária

## Definir JIT compilers
- compilador que gera código de máquina “na hora”, ou seja, durante a execução do código, ao invés de compilar tudo antes de rodar
- exemplos de uso: javascript em seu framework React, que compila enquanto roda a aplicação, atualizando quase instantaneamente durante a execução
